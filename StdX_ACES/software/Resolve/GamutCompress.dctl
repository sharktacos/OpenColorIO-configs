__CONSTANT__ float  threshold_r = 0.815f;
__CONSTANT__ float  threshold_g = 0.803f;
__CONSTANT__ float  threshold_b = 0.88f;
DEFINE_UI_PARAMS(power_select, power, DCTLUI_COMBO_BOX, 2, {A, B, C, D}, {1.0, 1.1, 1.2, 1.3});
__CONSTANT__ float  cyan = 0.147f;
__CONSTANT__ float  magenta = 0.264f;
__CONSTANT__ float  yellow = 0.312f;
__CONSTANT__ bool invert = 0;

// Convert acescg to acescct
__DEVICE__ float lin_to_acescct(float in) {
  if (in <= 0.0078125f) {
    return 10.5402377416545f * in + 0.0729055341958355f;
  } else {
    return (_log2f(in) + 9.72f) / 17.52f;
  }
}

// Convert acescct to acescg
__DEVICE__ float acescct_to_lin(float in) {
  if (in > 0.155251141552511f) {
    return _powf( 2.0f, in*17.52f - 9.72f);
  } else {
    return (in - 0.0729055341958355f) / 10.5402377416545f;
  }
}

// Convert acescg to acescc
__DEVICE__ float lin_to_acescc(float in) {
  if (in <= 0.0f) {
    return -0.3584474886f;
  } else if (in < _powf(2.0f, -15.0f)) {
    return (_log2f(_powf(2.0f, -16.0f) + in * 0.5f) + 9.72f) / 17.52f;
  } else {
    return (_log2f(in) + 9.72f) / 17.52f;
  }
}

// Convert acescc to acescg
__DEVICE__ float acescc_to_lin(float in) {
  if (in < -0.3013698630f) {
    return (_powf( 2.0f, in * 17.52f - 9.72f) - _powf( 2.0f, -16.0f)) * 2.0f;
  } else if (in < (_log2f(65504.0f)+9.72f)/17.52f) {
    return _powf(2.0f, in * 17.52f - 9.72f);
  } else {
    return 65504.0f;
  }
}

// calculate compressed distance
__DEVICE__ float compress(float dist, float lim, float thr, bool invert, float power) {
  float cdist, s;
  if (dist < thr) {
    cdist = dist;
  } else {
    // power(p) compression function plot https://www.desmos.com/calculator/54aytu7hek
    if (lim < 1.0001f) {
      return dist; // disable compression, avoid nan
    }
    s = (lim-thr)/_powf(_powf((1.0f-thr)/(lim-thr),-power)-1.0f,1.0f/power); // calc y=1 intersect
    if (invert == 0) {
      cdist = thr+s*((dist-thr)/s)/(_powf(1.0f+_powf((dist-thr)/s,power),1.0f/power)); // compress
    } else {
      if (dist > (thr + s)) {
        cdist = dist; // avoid singularity
      } else {
        cdist = thr+s*_powf(-(_powf((dist-thr)/s,power)/(_powf((dist-thr)/s,power)-1.0f)),1.0f/power); // uncompress
      }
    }
  }
  return cdist;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) 
{ 
  // ^-- this is necessary for the DCTL to work!

  // set power value from drop-down
  float power;
  if (power_select == A) {
    power = 1.0;
  }
  else if (power_select == B) {
    power = 1.1;
  }
  else if (power_select == C) {
    power = 1.2;
  }
  else if (power_select == D) {
    power = 1.3;
  }

  // normalised pixel coordinates
  float2 pos = make_float2((float)p_X / p_Width, (float)(p_Height - p_Y) / p_Height);

  // source pixels
  float3 rgb = make_float3(p_R, p_G, p_B);
  
  rgb.x = acescct_to_lin(rgb.x);
  rgb.y = acescct_to_lin(rgb.y);
  rgb.z = acescct_to_lin(rgb.z);

  // thr is the percentage of the core gamut to protect.
  float3 thr = make_float3(
    _fminf(0.9999f, threshold_r),
    _fminf(0.9999f, threshold_g),
    _fminf(0.9999f, threshold_b));
  
  // lim is the max distance from the gamut boundary that will be compressed
  // 0 is a no-op, 1 will compress colors from a distance of 2.0 from achromatic to the gamut boundary
  float3 lim = make_float3(cyan+1.0f, magenta+1.0f, yellow+1.0f);

  // achromatic axis 
  float ach = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));

  // distance from the achromatic axis for each color component aka inverse rgb ratios
  float3 dist;
  dist.x = ach == 0.0f ? 0.0f : (ach-rgb.x)/_fabs(ach);
  dist.y = ach == 0.0f ? 0.0f : (ach-rgb.y)/_fabs(ach);
  dist.z = ach == 0.0f ? 0.0f : (ach-rgb.z)/_fabs(ach);

  // compress distance with user controlled parameterized shaper function
  float sat;
  float3 csat, cdist;
  cdist = make_float3(
    compress(dist.x, lim.x, thr.x, invert, power),
    compress(dist.y, lim.y, thr.y, invert, power),
    compress(dist.z, lim.z, thr.z, invert, power));

  // recalculate rgb from compressed distance and achromatic
  // effectively this scales each color component relative to achromatic axis by the compressed distance
  float3 crgb = make_float3(
    ach-cdist.x*_fabs(ach),
    ach-cdist.y*_fabs(ach),
    ach-cdist.z*_fabs(ach));

  crgb.x = lin_to_acescct(crgb.x);
  crgb.y = lin_to_acescct(crgb.y);
  crgb.z = lin_to_acescct(crgb.z);

  // write output
  return crgb;
}